# XOR-linked-lists
Проект выполнен в рамках учебного курса "Основы программирования".

### Библиотека
Библиотека предоставляет интерфейс для работы со списком. Реализации этих функций находится в файле [xlist.c](xlist.c)

| Название | Описание | Ответсвенный | 
| -------- | -------- | ------------ | 
| [new_list](#new_list) | Создаёт новый список | Пермяков |
| [del_list](#del_list) | Освобождает память, занимаемую списком | Сорока |
| [addelem_end](#addelem_end) | Добавляет элемент в конец | Аксенов |
| [addelem_begin](#addelem_begin) | Добавляет элемент в начало | Аксенов |
| [felem_list](#felem_list) | Находит элемент в списке | Аляев |
| [symm_list](#symm_list) | ??? | Шурыгин |
| [print_list](#print_list) | Печатает список | Шурыгин |

## Тесты
В этом разделе содержатся описания работы всех функций из этой библиотеке. 

### new_list
`list_t* lst_new(int)`

Создаёт и инициализирует список и возвращает на него указатель. В случае нехватки памяти возвращается нулевой указатель. Параметр игнорируется.

**Пример:**
<!-- doctest: run -->
```c
list_t* L;
if (!(L = lst_new(0))) {
	/* ошибка при создании списка  */
	abort();
}
/* работаем со списком */
lst_free(L);
```

### del_list
`void lst_free(list_t* lst)`

Уничтожает список lst и освобождает память. Обязательно вызывайте эту функцию перед выходом из программы.

### addelem_end
`int lst_append(list_t* lst, lst_elem_t el)`

Вставляет элемент el в конец списка lst. В случае успеха возвращает ненулевое значение, иначе 0. Если произошли ошибки — список остаётся в корректном состоянии. Все итераторы списка остаются в валидном состоянии.

<!-- doctest: before -->
**Список до:** `96 78 84 61 57 30 43 50 71`

**Пример:**
<!-- doctest: code -->
```c
lst_append(L, 42);
lst_append(L, 13);
```

<!-- doctest: after -->
**Результат:** `96 78 84 61 57 30 43 50 71 42 13`

### addelem_begin
`int lst_insert_before(lst_iter_t it, lst_elem_t el)`

Вставляет элемент el перед тем, на который указывает it. В случае успеха возвращает ненулевое значение, иначе 0. Итераторы, указывающие на элементы после it остаются валиднымы (включая it). Итераторы до it могут быть испорчены, но не далее некоторого количества.

_Не реализована_

<!-- doctest: pass -->
**Список до:** `28 13 74 2 52 58 68 95 65`

**Пример:**
<!-- doctest: pass -->
```c
lst_iter_t p = lst_find(L, 68);
lst_insert_before(p, 42);
p = lst_iter_by_index(L, 3);
lst_insert_before(p, 13);
```

<!-- doctest: after -->
**Результат:** `28 13 74 13 2 52 58 42 68 95 65`

### felem_list
`void lst_delete(lst_iter_t it)`

Удаляет элемент, на который указывает it. it и некоторое количество итераторов после становятся недействительными. До it остаются валидными.

<!-- doctest: before -->
**Список до:** `64 54 89 76 52 71 4 23 24 52 94 69 29 22`

**Пример:**
<!-- doctest: code -->
```c
lst_delete(lst_find(L, 52));
lst_delete(lst_iter_by_index(L, 2));
lst_delete(lst_iter_by_index(L, 11));
```

<!-- doctest: after -->
**Результат:** `64 54 76 71 4 23 24 52 94 69 29`


### symm_list
<!-- doctest: before -->
**Список:** `37 13 78 78 13 29 78 6 13 51 90 32 13 95`

<!-- doctest: assert -->
```c
lst_count(L, 13) == 4;
lst_count(L, 78) == 3;
```

### print_list
<!-- doctest: before -->
**Список:** `20 88 70 63 5 21 19 89 47 94 87 9 55 79 62 93 97 34 16 61 72 12 38 31 15`

<!-- doctest: code -->
```c
lst_repack(L);
```

<!-- doctest: after -->
**Результат:** `20 88 70 63 5 21 19 89 47 94 87 9 55 79 62 93 97 34 16 61 72 12 38 31 15`



